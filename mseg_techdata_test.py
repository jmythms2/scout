#!/usr/bin/env python3

""" Tests for processing microsegment cost, performance, and lifetime data """

# Import code to be tested
import mseg_techdata

# Import needed packages
import unittest
import numpy


class StitchTest(unittest.TestCase):
    """ Test operation of stitch function, which reconstructs EIA performance,
    cost, and lifetime projections for a technology between a series of
    time periods (i.e. 2010-2014, 2014-2020, 2020-2040) in a dict with annual
    keys across a given modeling time horizon (i.e. {"2009": XXX, "2010": XXX,
    ..., "2040": XXX}) """

    # Define a test input array with valid EIA data to stich together
    # across modeling time horizon
    ok_array = numpy.array([(2008, 2012, 0.33, 14.5, 55, b'GSL', b'Inc'),
                            (2012, 2013, 1.03, 20, 60, b'GSL', b'Inc'),
                            (2013, 2017, 1.53, 21, 61.2, b'GSL', b'Inc'),
                            (2017, 2020, 2.75, 22, 80.3, b'GSL', b'Inc'),
                            (2020, 2040, 3.45, 23, 90, b'GSL', b'Inc')],
                           dtype=[('START_EQUIP_YR', '<i8'),
                                  ('END_EQUIP_YR', '<f8'),
                                  ('BASE_EFF', '<f8'),
                                  ('LIFE_HRS', '<f8'),
                                  ('INST_COST', '<f8'),
                                  ('NAME', 'S3'),
                                  ('BULB_TYPE', 'S3')])

    # Define a test input array with faulty EIA data that should yield an
    # error in the function execution (multiple rows with same starting year)
    fail_array = numpy.array([(2008, 2012, 0.33, 14.5, 55, b'GSL', b'Inc'),
                              (2012, 2013, 1.03, 20, 60, b'GSL', b'Inc'),
                              (2013, 2017, 1.53, 21, 61.2, b'GSL', b'Inc'),
                              (2017, 2020, 2.75, 22, 80.3, b'GSL', b'Inc'),
                              (2020, 2040, 3.45, 23, 90, b'GSL', b'Inc'),
                              (2013, 2017, 1.53, 21, 61.2, b'GSL', b'Inc'),
                              (2017, 2020, 2.75, 22, 80.3, b'GSL', b'Inc'),
                              (2020, 2040, 3.45, 23, 90, b'GSL', b'Inc')],
                             dtype=[('START_EQUIP_YR', '<i8'),
                                    ('END_EQUIP_YR', '<f8'),
                                    ('BASE_EFF', '<f8'),
                                    ('LIFE_HRS', '<f8'),
                                    ('INST_COST', '<f8'),
                                    ('NAME', 'S3'),
                                    ('BULB_TYPE', 'S3')])

    # Define the modeling time horizon to test
    years = [str(i) for i in range(2009, 2015 + 1)]
    project_dict = dict.fromkeys(years)

    # Define the each variable (column) in the input array with the values that
    # will be reconstructed annually across the modeling time horizon, based on
    # each row's 'START_EQUIP_YR' column value
    col_names = ['BASE_EFF', 'INST_COST', 'LIFE_HRS']

    # Define a dict of output values for the above variables in col_names that
    # should be generated by the function for each year of the modeling time
    # horizon based on the ok_array above
    ok_out = [{"2009": 0.33, "2010": 0.33, "2011": 0.33, "2012": 1.03,
               "2013": 1.53, "2014": 1.53, "2015": 1.53},
              {"2009": 55, "2010": 55, "2011": 55, "2012": 60,
               "2013": 61.2, "2014": 61.2, "2015": 61.2},
              {"2009": 14.5, "2010": 14.5, "2011": 14.5, "2012": 20,
               "2013": 21, "2014": 21, "2015": 21}]

    # Create a routine for checking equality of a dict
    def dict_check(self, dict1, dict2, msg=None):
        for (k, i), (k2, i2) in zip(sorted(dict1.items()),
                                    sorted(dict2.items())):
            if isinstance(i, dict):
                self.assertCountEqual(i, i2)
                self.dict_check(i, i2)
            else:
                self.assertAlmostEqual(dict1[k], dict2[k2], places=2)

    # Test that the function yields a correct output dict for each set of
    # variable values to be stitched together across the modeling time
    # horizon, given the ok_array above as an input
    def test_convert_match(self):
        for (idx, col_name) in enumerate(self.col_names):
            dict1 = mseg_techdata.stitch(
                self.ok_array, self.project_dict,
                col_name)
            dict2 = self.ok_out[idx]
            self.dict_check(dict1, dict2)

    # Test that the function yields a ValueError given the fail_array above,
    # which includes multiple rows with the same 'START_EQUIP_YR' column value
    def test_convert_fail(self):
        for (idx, col_name) in enumerate(self.col_names):
            with self.assertRaises(ValueError):
                mseg_techdata.stitch(self.fail_array, self.project_dict,
                                     col_name)


# Offer external code execution (include all lines below this point in all
# test files)
def main():
    # Triggers default behavior of running all test fixtures in the file
    unittest.main()

if __name__ == '__main__':
    main()
